-- emp 테이블에 empno 컬럼을 기준으로 PRIMARY KEY를 생성
-- PRIMARY KEY = UNIQUE + NOT NULL
-- UNIQUE → 해당 컬럼으로 UNIQUE INDEX를 자동으로 생성

ALTER TABLE emp ADD CONSTRAINT pk_emp PRIMARY KEY (empno);
-- PRIMARY KEY 를 사용하면서 만들어진 인덱스를 자동적으로 사용한 경우

EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE empno = 7369;

SELECT *
FROM TABLE(dbms_xplan.display);

--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 2949544139
 
--------------------------------------------------------------------------------------
| Id  | Operation                   | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |        |     1 |    37 |     1   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP    |     1 |    37 |     1   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | PK_EMP |     1 |       |     0   (0)| 00:00:01 |
--------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("EMPNO"=7369)  -- 인덱스에 접근할 때 사용되는 조건
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━



-- empno 컬럼으로 인덱스가 존재하는 상황에서 다른 컬럼 값으로 데이터를 조회하는 경우
EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE job = 'MANAGER';

SELECT *
FROM TABLE(dbms_xplan.display);

--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 3956160932
 
--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     3 |   111 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMP  |     3 |   111 |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("JOB"='MANAGER')
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


-- 인덱스 구성 컬럼만 SELECT 절에 기술한 경우
-- 테이블 접근이 필요없다

EXPLAIN PLAN FOR
SELECT empno
FROM emp
WHERE empno = 7782;

SELECT *
FROM TABLE(dbms_xplan.display);

--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 56244932
 
----------------------------------------------------------------------------
| Id  | Operation         | Name   | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |        |     1 |     4 |     0   (0)| 00:00:01 |
|*  1 |  INDEX UNIQUE SCAN| PK_EMP |     1 |     4 |     0   (0)| 00:00:01 |
-- 인덱스 컬럼만 읽어도 원하는 인덱스가 다 있다.
----------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - access("EMPNO"=7782)
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


-- 컬럼에 중복이 가능한 non-unique 인덱스 생성 후
-- unique index와의 실행계획 비교
-- PRIMARY KEY 제약조건 삭제 (unique 인덱스 삭제)
ALTER TABLE emp DROP CONSTRAINT pk_emp;
CREATE INDEX /*UNIQUE*/ IDX_emp_01 ON emp (empno);

EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE empno = 7782;

SELECT *
FROM TABLE(dbms_xplan.display);

--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 4208888661
 
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |    37 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP        |     1 |    37 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP_01 |     1 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("EMPNO"=7782)
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


-- emp 테이블에 job 컬럼으로 두 번째 인덱스 생성 (non-unique index)
-- job 컬럼은 다른 로우의 job 컬럼과 중복이 가능한 컬럼이다.
CREATE INDEX idx_emp_02 ON emp (job);

EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE job = 'MANAGER';

SELECT *
FROM TABLE(dbms_xplan.display);


--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 4079571388
 
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     3 |   111 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP        |     3 |   111 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP_02 |     3 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("JOB"='MANAGER')
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE job = 'MANAGER'
    AND ename LIKE 'C%';

SELECT *
FROM TABLE(dbms_xplan.display);

--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 4079571388
 
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |    37 |     2   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS BY INDEX ROWID| EMP        |     1 |    37 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP_02 |     3 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter("ENAME" LIKE 'C%')        -- 인덱스 확인 불가. 테이블에 접근을 해야지만 알 수 있는 값.
   2 - access("JOB"='MANAGER')
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━



-- emp 테이블에 job, ename 컬럼을 기준으로 non-unique 인덱스 생성
CREATE INDEX IDX_emp_03 ON emp (job, ename);


EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE job = 'MANAGER'
    AND ename LIKE 'C%';

SELECT *
FROM TABLE(dbms_xplan.display);


--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 2549950125
 
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |    37 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP        |     1 |    37 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_EMP_03 |     1 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("JOB"='MANAGER' AND "ENAME" LIKE 'C%')
       filter("ENAME" LIKE 'C%')        -- access랑 filter랑 동시에 됐다.
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


-- emp 테이블에 ename, job 컬럼으로 non-unique 인덱스 생성
CREATE INDEX IDX_emp_04 ON emp (ename, job);


EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE job = 'MANAGER'
    AND ename LIKE '%C';
-- 이런 경우는 인덱스를 사용하기 좋지 않은 예. 사용할지 안 할지도 알 수 없다.

EXPLAIN PLAN FOR
SELECT *
FROM emp
WHERE ename LIKE '%C'
    AND job = 'MANAGER';
-- WHERE 의 조건 순서가 바뀐다고 해서 결과가 달라지는 일은 없다. SQL은 Set의 개념이기 때문.

SELECT *
FROM TABLE(dbms_xplan.display);


--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Plan hash value: 4060516099
 
------------------------------------------------------------------------------------------
| Id  | Operation                   | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |            |     1 |    37 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP        |     1 |    37 |     2   (0)| 00:00:01 |
|*  2 |   INDEX SKIP SCAN           | IDX_EMP_04 |     1 |       |     1   (0)| 00:00:01 |
    -- 선행이 있을 거라고 생각하고 ename부터 쭉 스캔을 한다.
    -- 인덱스 컬럼 순서에 따라서도 결과가 바뀐다.
------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("JOB"='MANAGER')
       filter("JOB"='MANAGER' AND "ENAME" LIKE '%C' AND "ENAME" IS NOT NULL)
--━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


-- HINT를 사용한 실행계획 제어
    -- RDBS의 기본 사상은 사용자가 로직을 몰라서 사용할 수 있다. hint를 사용하면 그런 이점을 누리지 못한다고 싫어하는 사람들도 있음.
    -- WHERE 도 건드려보고 다 해봤는데 그래도 안 된다고 했을 때 마지막에 사용하는 식으로...

EXPLAIN PLAN FOR
SELECT /*+ INDEX (emp idx_emp_01) */ *      -- 오라클에서 개발자의 명령을 듣는 주석 처리 부분(HINT)
FROM emp
WHERE job = 'MANAGER'
    AND ename LIKE '%C';
-- 이런 경우는 인덱스를 사용하기 좋지 않은 예. 사용할지 안 할지도 알 수 없다.

SELECT *
FROM TABLE(dbms_xplan.display);


        -- CTAS


-- ■ DDL (index 실습 idx1) -----------------------------------------------------------------------------------------------------------------------
-- CREATE TABLE DEPT_TEST AS SELECT * FROM DEPT WHERE 1 = 1 구문으로 DEPT_TEST 테이블 생성 후 다음
-- 조건에 맞는 인덱스를 생성하세요.

CREATE TABLE dept_test AS
SELECT *
FROM dept
WHERE 1 = 1;

SELECT *
FROM dept_test;

-- 1. deptno 컬럼을 기준으로 unique 인덱스 생성
ALTER TABLE dept_test ADD CONSTRAINT pk_dept_test PRIMARY KEY (deptno);

-- 2. dname 컬럼을 기준으로 non-unique 인덱스 생성
CREATE INDEX idx_emp_test ON dept_test (dname);

-- 3. deptno, dname 컬럼을 기준으로 non-unique 인덱스 생성
CREATE INDEX idx2_emp_test ON dept_test (deptno, dname);
----------------------------------------------------------------------------------------------------------------------------------------------------------


-- ■ DDL (index 실습 idx2) -----------------------------------------------------------------------------------------------------------------------
-- 실습 idx1에서 생성한 인덱스를 삭제하는 DDL 문을 작성하세요.
ALTER TABLE dept_test DROP CONSTRAINT pk_dept_test;
DROP INDEX idx_emp_test;
DROP INDEX idx2_emp_test;
----------------------------------------------------------------------------------------------------------------------------------------------------------

-- ■ DDL (index 실습 idx3) -----------------------------------------------------------------------------------------------------------------------
-- 시스템에서 사용하는 쿼리가 다음과 같다고 할 때 적절한 emp 테이블에 필요하다고 생각되는 인덱스의 생성 스크립트를
-- 만들어보세요.
SELECT *
FROM emp
WHERE empno = 7298;

SELECT *
FROM emp
WHERE ename = 'SCOTT';

SELECT *
FROM emp
WHERE sal BETWEEN 500 AND 7000
    AND deptno = 20;
    
SELECT *
FROM emp, dept
WHERE emp.deptno = dept.deptno
    AND emp.deptno = 10
    AND emp.empno LIKE '78%';
    
SELECT B.*
FROM emp A, emp B
WHERE A.mgr = B.empno
    AND A.deptno = 30;

ALTER TABLE emp ADD CONSTRAINT pk_emp_idxtest1 PRIMARY KEY (empno);

CREATE INDEX idx_emp_test_1 ON emp (ename);
CREATE INDEX idx_emp_test_2 ON emp (deptno);
CREATE INDEX idx_emp_test_3 ON emp (deptno, mgr);
-- CREATE INDEX idx_dept_test_1 ON dept (deptno); -- 이미 PRAIMARY KEY 가 있음.
----------------------------------------------------------------------------------------------------------------------------------------------------------

